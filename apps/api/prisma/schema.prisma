generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String              @id @default(uuid())
  email               String              @unique
  garminUserId        String?             @unique
  accessToken         String?
  refreshToken        String?
  tokenExpiresAt      DateTime?
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  name                String?
  avatarUrl           String?
  emailVerified       DateTime?
  passwordHash        String?
  age                 Int?
  location            String?
  onboardingCompleted Boolean             @default(false)
  activeDataSource    AuthProvider?
  stravaUserId        String?             @unique
  whoopUserId         String?             @unique
  role                UserRole            @default(WAITLIST)
  mustChangePassword  Boolean             @default(false)
  activatedAt         DateTime?
  activatedBy         String?
  isFoundingRider     Boolean             @default(false)
  emailUnsubscribed   Boolean             @default(false)
  hoursDisplayPreference String?          @default("remaining")
  predictionMode         String?          @default("simple")
  calibrationCompletedAt DateTime?
  calibrationDismissedAt DateTime?
  pairedComponentMigrationSeenAt DateTime?
  bikes               Bike[]
  components          Component[]
  tokens              OauthToken[]
  rides               Ride[]
  stravaGearMappings  StravaGearMapping[]
  accounts            UserAccount[]
  emailSends          EmailSend[]
  termsAcceptances    TermsAcceptance[]
  backfillRequests    BackfillRequest[]
  importSessions      ImportSession[]
}

model OauthToken {
  id           String       @id @default(cuid())
  userId       String
  accessToken  String
  refreshToken String?
  expiresAt    DateTime
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  provider     AuthProvider
  User         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider])
}

model UserAccount {
  id             String       @id @default(cuid())
  userId         String
  provider       AuthProvider
  providerUserId String
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerUserId])
  @@index([userId])
}

model Ride {
  id                String          @id @default(uuid())
  userId            String
  garminActivityId  String?         @unique
  startTime         DateTime
  durationSeconds   Int
  averageHr         Int?
  rideType          String
  bikeId            String?
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  distanceMiles     Float
  elevationGainFeet Float
  notes             String?
  location          String?
  trailSystem       String?
  duplicateOfId     String?
  isDuplicate       Boolean         @default(false)
  stravaActivityId  String?         @unique
  stravaGearId      String?
  whoopWorkoutId    String?         @unique
  importSessionId   String?
  bike              Bike?           @relation(fields: [bikeId], references: [id])
  duplicateOf       Ride?           @relation("DuplicateRides", fields: [duplicateOfId], references: [id], onDelete: SetNull)
  duplicates        Ride[]          @relation("DuplicateRides")
  user              User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  importSession     ImportSession?  @relation(fields: [importSessionId], references: [id], onDelete: SetNull)

  @@index([importSessionId, bikeId])
}

model Bike {
  id                 String              @id @default(uuid())
  userId             String
  nickname           String?
  manufacturer       String
  model              String
  travelForkMm       Int?
  travelShockMm      Int?
  notes              String?
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  year               Int?
  sortOrder          Int                 @default(0)
  spokesId           String?
  buildKind          String?
  category           String?
  family             String?
  frameMaterial      String?
  gender             String?
  hangerStandard     String?
  isEbike            Boolean             @default(false)
  isFrameset         Boolean             @default(false)
  spokesUrl          String?
  subcategory        String?
  batteryWh          Int?
  motorMaker         String?
  motorModel         String?
  motorPowerW        Int?
  motorTorqueNm      Int?
  thumbnailUrl         String?
  acquisitionCondition AcquisitionCondition?
  user                 User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  components           Component[]
  Ride                 Ride[]
  stravaGearMappings   StravaGearMapping[]

  @@index([spokesId])
}

model StravaGearMapping {
  id             String   @id @default(uuid())
  userId         String
  stravaGearId   String
  stravaGearName String?
  bikeId         String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  bike           Bike     @relation(fields: [bikeId], references: [id], onDelete: Cascade)
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, stravaGearId])
  @@index([userId])
  @@index([bikeId])
}

model Component {
  id                    String             @id @default(uuid())
  bikeId                String?
  type                  ComponentType
  location              ComponentLocation  @default(NONE)
  brand                 String
  model                 String
  installedAt           DateTime?
  hoursUsed             Float              @default(0)
  serviceDueAtHours     Float?
  notes                 String?
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt
  isStock               Boolean            @default(false)
  baselineWearPercent   Int?               @default(0)
  baselineMethod        BaselineMethod     @default(DEFAULT)
  baselineConfidence    BaselineConfidence @default(HIGH)
  baselineSetAt         DateTime?
  lastServicedAt        DateTime?
  userId                String

  // Front/rear pairing support
  pairGroupId           String?
  retiredAt             DateTime?
  replacedById          String?            @unique

  bike                  Bike?              @relation(fields: [bikeId], references: [id])
  user                  User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  serviceLogs           ServiceLog[]

  // Self-referential relation for replacement chain
  replacedBy            Component?         @relation("ComponentReplacement", fields: [replacedById], references: [id])
  replaces              Component?         @relation("ComponentReplacement")

  // Unique constraint: one active component per bike/type/location combination
  // Note: Retired components (retiredAt != null) should have bikeId set to null
  // to avoid constraint violations when replacing components
  @@unique([bikeId, type, location], name: "unique_active_component_per_bike_location")
  @@index([userId])
  @@index([bikeId])
  @@index([pairGroupId])
}

model ServiceLog {
  id             String    @id @default(uuid())
  component      Component @relation(fields: [componentId], references: [id], onDelete: Cascade)
  componentId    String
  performedAt    DateTime  @default(now())
  notes          String?
  hoursAtService Float     @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([componentId])
  @@index([performedAt])
}

enum AuthProvider {
  garmin
  google
  strava
  whoop
}

enum UserRole {
  WAITLIST
  FREE
  PRO
  ADMIN
}

enum ComponentLocation {
  FRONT
  REAR
  NONE
}

enum ComponentType {
  FORK
  SHOCK
  BRAKES
  DRIVETRAIN
  TIRES
  WHEEL_HUBS @map("WHEELS")
  DROPPER
  PEDALS
  CHAIN
  CASSETTE
  OTHER
  PIVOT_BEARINGS
  STEM
  HANDLEBAR
  SADDLE
  SEATPOST
  RIMS
  CRANK
  REAR_DERAILLEUR
  BRAKE_PAD
  BRAKE_ROTOR
  HEADSET
  BOTTOM_BRACKET
}

enum AcquisitionCondition {
  NEW
  USED
  MIXED
}

enum BaselineMethod {
  DEFAULT
  SLIDER
  DATES
}

enum BaselineConfidence {
  LOW
  MEDIUM
  HIGH
}

enum EmailType {
  activation
  welcome_series
  announcement
  custom
  founding_welcome
  founding_post_activation_info
  strava_integration_live
}

enum TriggerSource {
  admin_manual
  system_activation
  system_welcome_series
  scheduled
}

enum EmailStatus {
  sent
  failed
  suppressed
}

model EmailSend {
  id                String        @id @default(cuid())
  userId            String
  user              User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  emailType         EmailType
  toEmail           String
  templateVersion   String?
  triggerSource     TriggerSource
  createdAt         DateTime      @default(now())
  providerMessageId String?
  status            EmailStatus
  failureReason     String?

  @@index([userId])
  @@index([createdAt])
  @@index([triggerSource])
  @@index([userId, createdAt])
  @@index([status, createdAt])
  @@index([emailType, triggerSource])
}

enum ScheduledEmailStatus {
  pending
  processing
  sent
  cancelled
  failed
}

model ScheduledEmail {
  id              String               @id @default(cuid())
  subject         String
  messageHtml     String               @db.Text
  templateType    String               @default("announcement")
  recipientIds    String[]
  recipientCount  Int
  scheduledFor    DateTime
  status          ScheduledEmailStatus @default(pending)
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt
  createdBy       String
  sentCount       Int?
  failedCount     Int?
  suppressedCount Int?
  processedAt     DateTime?
  errorMessage    String?

  @@index([status])
  @@index([scheduledFor])
  @@index([createdBy])
}

model GeoCache {
  id        String   @id @default(cuid())
  lat       Float
  lon       Float
  location  String?
  createdAt DateTime @default(now())

  @@unique([lat, lon])
}

model BackfillRequest {
  id             String              @id @default(cuid())
  userId         String
  user           User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  provider       AuthProvider
  year           String              // "ytd", "2025", "2024", etc.
  status         BackfillStatus      @default(pending)
  ridesFound     Int?
  backfilledUpTo DateTime?           // For YTD: the end timestamp of last backfill
  createdAt      DateTime            @default(now())
  updatedAt      DateTime            @updatedAt
  completedAt    DateTime?

  @@unique([userId, provider, year])
  @@index([userId])
  @@index([userId, provider])
}

enum BackfillStatus {
  pending
  in_progress
  completed
  failed
}

enum ImportSessionStatus {
  running
  completed
  failed
}

model TermsAcceptance {
  id           String   @id @default(cuid())
  userId       String
  termsVersion String
  acceptedAt   DateTime @default(now())
  ipAddress    String?
  userAgent    String?
  createdAt    DateTime @default(now())
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, termsVersion])
  @@index([userId])
}

model ImportSession {
  id                     String              @id @default(cuid())
  userId                 String
  user                   User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  provider               AuthProvider
  status                 ImportSessionStatus @default(running)
  startedAt              DateTime            @default(now())
  lastActivityReceivedAt DateTime?
  completedAt            DateTime?
  unassignedRideCount    Int                 @default(0)
  userAcknowledgedAt     DateTime?
  createdAt              DateTime            @default(now())
  updatedAt              DateTime            @updatedAt
  rides                  Ride[]

  @@index([userId])
  @@index([userId, provider, status])
  @@index([status, lastActivityReceivedAt])
}
